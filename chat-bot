#!/bin/bash

init_variables(){
    #fonction intialisant les variables globaux   
    ROBOT_DEFAULT_NAME="bot"
    RECEIVER="$1"
    ROBOT="${2:-$ROBOT_DEFAULT_NAME}"

}

create_communication_pipes(){
    SENDER_PIPE="/tmp/${ROBOT}-${RECEIVER}.chat"
    RECEIVER_PIPE="/tmp/${RECEIVER}-${ROBOT}.chat"
    # -p fichier de type pipe fifo

    #nouvelle idee: si le fichier SENDER_PIPE ou RECEIVER_PIPE
    # existe et qu'il n'est pas de type fifo ('-p')
    # forcer sa supression du Filesystem et recreer!
    # -e --> si fichier existe
    # -p --> si fichier de type pipe FIFOs
    # -f --> forcer la supression 
    if [[ -e "$SENDER_PIPE" && ! -p "$SENDER_PIPE" ]]
    then
        rm -f "$SENDER_PIPE"
    fi

    if [[ -e "$RECEIVER_PIPE" && ! -p "$RECEIVER_PIPE" ]]
    then
        rm -f "$RECEIVER_PIPE"
    fi
    

    # creation du pipe d'envoie
    if [[ ! -p "$SENDER_PIPE" ]] 
    then
        mkfifo -m 0666 "$SENDER_PIPE"
        echo "[SUCESS] : created $SENDER_PIPE"
    fi
    # creation du pipe de reception
    if [[ ! -p "$RECEIVER_PIPE" ]] 
    then
        mkfifo -m 0666 "$RECEIVER_PIPE"
        echo "[SUCESS] : created $RECEIVER_PIPE"
    fi
    
}

cleanup_pipes(){
    rm -f "$RECEIVER_PIPE" "$SENDER_PIPE"
    echo "[CLEANUP] : Deleted pipes $SENDER_PIPE and $RECEIVER_PIPE from Filesystem!"
}

#fonction pour enovyer les messages au destinataire
send_message(){
    local msg="$1" # le message est le 1er param..
    echo "$msg" > "$SENDER_PIPE"
}

#fonction pour lire les messages du destinataire
read_message(){
    local msg
    read -r msg < "$RECEIVER_PIPE"
    echo "$msg"
}

#fonction executer la command 'liste'
list_current_directory(){
    send_message "$(ls)"
}

#fonnction pour lire un fichier --> commande 'li'
read_file(){
    local to_read_file="$1"
    # -f est fichier de type ordinaire != foder/special file
    if [[ -f "$to_read_file" ]]
    then
        send_message "$(cat "$to_read_file")"
    else
        send_message "[ERROR] : '$to_read_file' n'existe pas!"
    fi
}

#fonction pour la commande whoami
whoami(){
    local username="$RECEIVER"
    send_message "$username"
}

#fonction pour la commande au revoir
goodbye(){
    send_message "Au revoir !"
    exit 0
}

unknown_command(){
    send_message "ðŸ¤– ?"
}

check_listebot_file(){
    local user_command="$1"
    local bot_response=$(grep "^$user_command" liste-bot.txt)
    if [[ -n "$bot_response" ]]
    then
        send_message "$(echo "$bot_response" | cut -d ' ' -f2-)"
    else
        unknown_command
    fi

}

process_commands(){
    while [[ true ]]; do
        # lecture des message du receiver
        msg=$(read_message)
        # verifier si l'utilisateur a ecrit qqch
        if [[ -z "$msg" ]]
        then
            continue # attendre qu'on entre une commande
        fi

        #Traitment des commands
        #Verification si exisitent dans liste-bot.txt
        #....
        case "$msg" in 
            "liste") 
                 list_current_directory
            ;;
            li\ *)
                to_read_file="${msg#li }"
                read_file
            ;;
            "au revoir") 
                goodbye
            ;;
            "qui suis-je")
            whoami
            ;;
            *)
            #else checker les autre commands
            check_listebot_file "$msg"
        esac
        
    done
    
}




# MAIN --> RUN
#initialisation du setup
init_variables "$@"
create_communication_pipes

# Appel de 'process_commands' la 'main' focniton
process_commands
trap cleanup_pipes EXIT
