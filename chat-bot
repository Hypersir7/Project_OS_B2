#!/bin/bash

cleanup_done=false

init_variables(){
    #fonction intialisant les variables globaux   
    ROBOT_DEFAULT_NAME="bot"
    RECEIVER="$1"
    ROBOT="${2:-$ROBOT_DEFAULT_NAME}"

}

create_communication_pipes(){
    SENDER_PIPE="/tmp/${ROBOT}-${RECEIVER}.chat"
    RECEIVER_PIPE="/tmp/${RECEIVER}-${ROBOT}.chat"
    # -p fichier de type pipe fifo

    #nouvelle idee: si le fichier SENDER_PIPE ou RECEIVER_PIPE
    # existe et qu'il n'est pas de type fifo ('-p')
    # forcer sa supression du Filesystem et recreer!
    # -e --> si fichier existe
    # -p --> si fichier de type pipe FIFOs
    # -f --> forcer la supression 
    if [[ -e "$SENDER_PIPE" && ! -p "$SENDER_PIPE" ]]
    then
        rm -f "$SENDER_PIPE"
    fi

    if [[ -e "$RECEIVER_PIPE" && ! -p "$RECEIVER_PIPE" ]]
    then
        rm -f "$RECEIVER_PIPE"
    fi
    

    # creation du pipe d'envoie
    if [[ ! -p "$SENDER_PIPE" ]] 
    then
        mkfifo -m 0666 "$SENDER_PIPE"
        echo "[SUCESS] : created $SENDER_PIPE"
    fi
    # creation du pipe de reception
    if [[ ! -p "$RECEIVER_PIPE" ]] 
    then
        mkfifo -m 0666 "$RECEIVER_PIPE"
        echo "[SUCESS] : created $RECEIVER_PIPE"
    fi
    
}

cleanup_pipes(){
    if [[ "$cleanup_done" == false ]]
    then
        rm -f "$RECEIVER_PIPE" "$SENDER_PIPE"
        echo "[CLEANUP] : Deleted pipes $SENDER_PIPE and $RECEIVER_PIPE from Filesystem!"
        cleanup_done=true
    fi
}

#fonction pour enovyer les messages au destinataire
send_message(){
    local msg="$1" # le message est le 1er param..
    if [[ -p "$SENDER_PIPE" ]]
    then
        echo "$msg" > "$SENDER_PIPE"
    else
        echo "[ERROR] : Pipe '$SENDER_PIPE' n'existe pas! "
        return 1 # renovyer un code d'erreur si problem
    fi
}

#fonction pour lire les messages du destinataire
read_message(){
    while true
    do
        if [[ -p "$RECEIVER_PIPE" ]]
        then
            if read -r msg < "$RECEIVER_PIPE"
            then
                echo "$msg"
                break # ici si un msg est lu avec sucess sortir de la boucle_. fin fonction
            fi
        else
            echo "[ERROR] : Pipe '$RECEIVER_PIPE' n'existe pas!"
            exit 1
        fi
    done
}

#fonction executer la command 'liste'
list_current_directory(){
    send_message "$(ls)"
}

#fonnction pour lire un fichier --> commande 'li'
read_file(){
    local to_read_file="$1"
    # -f est fichier de type ordinaire != foder/special file
    if [[ -f "$to_read_file" ]]
    then
        send_message "$(cat "$to_read_file")"
    else
        send_message "[ERROR] : '$to_read_file' n'existe pas!"
    fi
}

#fonction pour la commande whoami
whoami(){
    local username="$RECEIVER"
    send_message "$username"
}

#fonction pour la commande au revoir
goodbye(){
    send_message "Au revoir !"
}

unknown_command(){
    send_message "ðŸ¤– ?"
}

check_listebot_file(){
    local user_command="$1"
    local bot_response=$(grep "^$user_command" liste-bot.txt)
    if [[ -n "$bot_response" ]]
    then
        send_message "$(echo "$bot_response" | cut -d ' ' -f2-)"
    else
        unknown_command
    fi

}

process_commands(){
    while [[ true ]]; do
        # lecture des message du receiver
        msg=$(read_message)
        # verifier si l'utilisateur a ecrit qqch
        if [[ -z "$msg" ]]
        then
            continue # attendre qu'on entre une commande
        fi

        #Traitment des commands
        #Verification si exisitent dans liste-bot.txt
        #....
        case "$msg" in 
            "liste") 
                 list_current_directory
            ;;
            li\ *)
                to_read_file="$(echo "${msg#li }" | xargs)"
                read_file
            ;;
            "au revoir") 
                goodbye
                sleep 1
                exit 0
            ;;
            "qui suis-je")
            whoami
            ;;
            *)
            #else checker les autre commands
            check_listebot_file "$msg"
        esac
        
    done
    
}




# MAIN --> RUN
#initialisation du setup
init_variables "$@"


create_communication_pipes

trap 'cleanup_pipes; exit 0' EXIT SIGINT SIGTERM

# Appel de 'process_commands' la 'main' focniton
process_commands

